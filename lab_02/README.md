## lab_02

Реализация таких структур данных как: односвязный, двусвязный список, кольцевой буфер.

Данные структуры должны поддерживать следующие операции/свойства:

- push - вставка элемента в структуру; ([1][id_1])
- pop - выталкивание элемента из структуры;([2][id_2])
- insert - вставка элемента в произвольное место структуры;
- erase - удаление элемента из произвольного места структуры;
- begin - возврат указателя (итератора) на начало структуры (первого элемента);
- end - возврат указателя (итератора) за конец структуры;
- count - возврат количества элементов в структуре;
- динамический размер - размер структуры должен увеличиваться при необходимости;([3][id_3])
- операторы сравнения (>, <, !=, etc) - объекты структур должны поддерживать операции **лексикографического** сравнения;
- не должны содержать в себе STL контейнеров;

Бонусы (не обязательно к выполнению):

- перегрузка оператора потокового вывода (`<<`) - предоставить возможность вывода содержимого структуры используя подобную конструкцию: `std::cout << "Elements: " << my_structure;`
- шаблонный интерфейс - структура является по своей сути контейнером, может содержать элементы любого типа (`my_structure<int> int_obj; my_structure<float> float_obj`);
- поддержка *initialized_list* - реализация конструктора, поддерживающего *brace-list* инициализацию (`my_structure<int> int_obj {0, 1, 5, 2, 3}`);
- использование умных указателей (*smart pointers*);
- поддержка итератора - классы должны предоставлять интерфейс итератора для возможности прохода по элементам структуры.

[id_1]: Вставка в начало и конец структуры; для кольцевого буфера реализуется только вставка в конец.

[id_2]: Удаление из начала и конца структуры; для кольцевого буфера реализуется только удаление из начала.

[id_3]: За исключением реализации кольцевого буфера, для него размер задаётся пользователем.

### Что Вы должны сделать:

Ниже представлен список **индивидуальных** заданий:

- вариант 1: реализация - 
  - слияния двух упорядоченных (по возрастанию) списков в один упорядоченный;
  - разбиения на две структуры по пороговому значению;([1][tsk_1])
- вариант 2: определение -
  - значения (первого) элемента, который следует за элементом с заданным значением;
  - (поиск) порядкового номера элемента списка с заданным значением;([2][tsk_2])
- вариант 3: сортировка - 
  - Хоара (быстрая сортировка);
  - слиянием (*merge sort*);
- вариант 4: реализация - 
  - проверки вхождения одной структуры в другую посредством циклического сдвига элементов;([3][tsk_3])
  - вычленения из списка максимального и минимального элементов и формирование нового списка.([4][tsk_4])

[tsk_1]: Разбиение списка на два в соответствии с заданным пороговым значением. Элементы с значениями, меньшими порогового, должны попасть в один список, остальные - в другой.

[tsk_2]: Подразумевается возврат итератора/указателя.

[tsk_3]: Даны два списка. Проверить, может ли быть получен второй список в результате циклического сдвига элементов первого списка.

[tsk_4]: Например, дан список с эл-ми {1, 2, 0, 6, 32, 3}, вызов метода`MinMaxList(..)` вернёт пару значений <0, 32>, и удалит из списка соответствующие элементы.

** **

Ваши **структуры должны** поддерживать реализации индивидуальных заданий (если не было указано иное). 

### Сборка

Все представленные ниже инструкции используются для _*nix_ семейства ОС.  Для пользователей ОС Windows может понадобиться использование других инструкций (либо вы можете использовать *Cygwin* или *MinGW*).

Для сборки с помощью `make` (Makefile):

```bash
$ cd <to repo path>/lab_02
$ make
```

Для сборки с помощью `cmake` (CMakeLists.txt):

```bash
$ cd <to repo path>/lab_02
$ cmake .
$ make
```

### Отчёт

В отчёте должно содержаться:

- перечисление **выполненных** заданий;
- листинг (код) программы;
- тестирование программы;
- сравнение производительности основных операций между вашими структурами и STL контейнерами;
- вывод скомпилированной программы;
- вывод по проделанной работе.