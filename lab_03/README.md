## lab_03

Реализация таких нелинейных структур данных как: обычное (*general*) дерево, бинарное дерево поиска.

Данные структуры должны поддерживать следующие операции/свойства:

- push - вставка элемента в структуру; ([1](#id_1))
- pop - выталкивание элемента из структуры;([2](#id_2))
- find - поиск элемента в структуре;
- count - возврат количества элементов в структуре;
- height - возврат высоты дерева;
- path - подсчёт длины пути от корня до указанного узла;([3](#id_3))
- print - вывод дерева в консоль;([4](#id_4))
- балансировка - привести дерево к виду, в котором для каждого узла, высота в его левом и правом поддеревьях отличается не более чем на 1;([5](#id_5))
- динамический размер - размер структуры должен увеличиваться при необходимости;
- операторы сравнения (>, <, !=, etc) - объекты структур должны поддерживать операции **лексикографического** сравнения;

Бонусы (не обязательно к выполнению):

- перегрузка оператора потокового вывода (`<<`) - предоставить возможность вывода содержимого структуры используя подобную конструкцию: `std::cout << "Elements: " << my_structure;`
- шаблонный интерфейс - структура является по своей сути контейнером, может содержать элементы любого типа (`my_structure<int> int_obj; my_structure<float> float_obj`);
- поддержка *initialized_list* - реализация конструктора, поддерживающего *brace-list* инициализацию (`my_structure<int> int_obj {0, 1, 5, 2, 3}`);
- использование умных указателей (*smart pointers*);
- поддержка итератора - классы должны предоставлять интерфейс итератора для возможности прохода по элементам структуры.

##### id_1: БД - упорядоченно; обычное - с указанием узла.

##### id_2: "Выталкивает" лист.

##### id_3: Если узлов с указанным элементом более одного, вернуть множество длин до каждого из узлов. Т.е. если в дереве несколько узлов с элементом 5, и длина до каждого из них равна 3, 5, 8, то метод `path` вернёт {3, 5, 8}. 
*Hint*: для возвращения одним методом вариативного типа, используйте *std::variant (C++17)*.

##### id_4: В *preorder* порядке.

##### id_5: Реализуется только для двоичного дерева.

### Что Вы должны сделать:

Ниже представлен список **индивидуальных** заданий:

- вариант 1: исключение - 
  - всех дублируемых значений;
  - узлов с указанным значением;
- вариант 2: реализация - 
  - обмена деревьями;
  - сложение двух деревьев;([1](#pr_1))
- вариант 3: преобразование - 
  - дерева в связный список;
  - множество элементов в сбалансированное бинарное дерево;([2](#pr_2))
- вариант 4: реализация - 
  - сложения (слияние) деревьев;
  - разбиение дерева на два.

##### pr_1: Складываются все узлы деревьев.  В качестве результата возвращается число.

##### pr_2: Дана последовательность { 1, 5, 3, 7, 9, 10, -3, -14, 22 } - на основе данной последовательности построить сбалансированное бинарное дерево.

** **

Ваши **структуры должны** поддерживать реализации индивидуальных заданий (если не было указано иное).  При этом, **решения индивидуальных заданий не должны являться методами** ваших классов (т.е. **решение задания - внешняя функция** взаимодействующая с вашей структурой).

### Сборка

Все представленные ниже инструкции используются для _*nix_ семейства ОС.  Для пользователей ОС Windows может понадобиться использование других инструкций (либо вы можете использовать *Cygwin* или *MinGW*).

Для сборки с помощью `make` (Makefile):

```bash
$ cd <to repo path>/lab_03
$ make
```

Для сборки с помощью `cmake` (CMakeLists.txt):

```bash
$ cd <to repo path>/lab_03
$ cmake .
$ make
```

### Отчёт

В отчёте должно содержаться:

- перечисление **выполненных** заданий;
- листинг (код) программы;
- тестирование программы;
- получение производительности основных операций ваших структур;
- вывод скомпилированной программы;
- вывод по проделанной работе.