## lab_03

Реализация таких нелинейных структур данных как: обычное (*general*) дерево, бинарное дерево поиска.

Данные структуры должны поддерживать следующие операции/свойства:

- push - вставка элемента в структуру; [1]
- pop - выталкивание элемента из структуры;[2]
- find - поиск элемента в структуре;
- count - возврат количества элементов в структуре;
- height - возврат высоты дерева;
- path - подсчёт длины пути от корня до указанного узла;[3]
- print - вывод дерева в консоль;[4]
- балансировка - привести дерево к виду, в котором для каждого узла, высота в его левом и правом поддеревьях отличается не более чем на 1;[5]
- динамический размер - размер структуры должен увеличиваться при необходимости;
- операторы сравнения (>, <, !=, etc) - объекты структур должны поддерживать операции **лексикографического** сравнения;

Бонусы (не обязательно к выполнению):

- перегрузка оператора потокового вывода (`<<`) - предоставить возможность вывода содержимого структуры используя подобную конструкцию: `std::cout << "Elements: " << my_structure;`
- шаблонный интерфейс - структура является по своей сути контейнером, может содержать элементы любого типа (`my_structure<int> int_obj; my_structure<float> float_obj`);
- поддержка *initialized_list* - реализация конструктора, поддерживающего *brace-list* инициализацию (`my_structure<int> int_obj {0, 1, 5, 2, 3}`);
- использование умных указателей (*smart pointers*);
- поддержка итератора - классы должны предоставлять интерфейс итератора для возможности прохода по элементам структуры.

##### [1]: БД - упорядоченно; обычное - с указанием узла.

##### [2]: "Выталкивает" лист.

##### [3]: Если узлов с указанным элементом более одного, вернуть множество длин до каждого из узлов. Т.е. если в дереве несколько узлов с элементом 5, и длина до каждого из них равна 3, 5, 8, то метод `path` вернёт {3, 5, 8}. 
*Hint*: для возвращения одним методом вариативного типа, используйте *std::variant (C++17)*.

##### [4]: В *preorder* порядке.

##### [5]: Реализуется только для двоичного дерева.  



### Что Вы должны сделать:

Ниже представлен список **индивидуальных** заданий:

- вариант 1: исключение - 
  - всех дублируемых значений;
  - узлов с указанным значением;
- вариант 2: реализация - 
  - обмена деревьями;
  - сложение двух деревьев;[1]
- вариант 3: преобразование - 
  - дерева в связный список;
  - множество элементов в сбалансированное бинарное дерево;[2]
- вариант 4: реализация - 
  - сложения (слияние) деревьев;
  - разбиение дерева на два.

##### [1]: Складываются все узлы деревьев.  В качестве результата возвращается число.

##### [2]: Дана последовательность { 1, 5, 3, 7, 9, 10, -3, -14, 22 } - на основе данной последовательности построить сбалансированное бинарное дерево.

** **

Ваши **структуры должны** поддерживать реализации индивидуальных заданий (если не было указано иное).  При этом, **решения индивидуальных заданий не должны являться методами** ваших классов (т.е. **решение задания - внешняя функция** взаимодействующая с вашей структурой).

### Сборка

Все представленные ниже инструкции используются для _*nix_ семейства ОС.  Для пользователей ОС Windows может понадобиться использование других инструкций (либо вы можете использовать *Cygwin* или *MinGW*).

Для сборки с помощью `make` (Makefile):

```bash
$ cd <to repo path>/lab_03
$ make
```

Для сборки с помощью `cmake` (CMakeLists.txt):

```bash
$ cd <to repo path>/lab_03
$ cmake .
$ make
```

### Отчёт

В отчёте должно содержаться:

- перечисление **выполненных** заданий;
- листинг (код) программы;
- тестирование программы;
- получение производительности основных операций ваших структур;
- вывод скомпилированной программы;
- вывод по проделанной работе.