## lab_04

Реализация таких нелинейных структур данных как: словарь, хеш-таблица.

Данные структуры должны поддерживать следующие операции/свойства:

- emplace - вставка элемента в структуру; [1]
- erase - удаление элемента из структуры;
- find - поиск элемента в структуре;
- count - возврат количества элементов в структуре;
- динамический размер - размер структуры должен увеличиваться при необходимости;
- операторы сравнения (>, <, !=, etc) - объекты структур должны поддерживать операции **лексикографического** сравнения;

Бонусы (не обязательно к выполнению):

- перегрузка оператора потокового вывода (`<<`) - предоставить возможность вывода содержимого структуры используя подобную конструкцию: `std::cout << "Elements: " << my_structure;`
- шаблонный интерфейс - структура является по своей сути контейнером, может содержать элементы любого типа (`my_structure<int> int_obj; my_structure<float> float_obj`);
- поддержка *initialized_list* - реализация конструктора, поддерживающего *brace-list* инициализацию (`my_structure<int> int_obj {0, 1, 5, 2, 3}`);
- использование умных указателей (*smart pointers*);
- поддержка итератора - классы должны предоставлять интерфейс итератора для возможности прохода по элементам структуры;
- compile time вычисление хеша - реализация вычисления хеша за время компиляции (для тех, у к-ого вариант с хеш-таблицей).

##### [1]: В словаре не должно быть дубликатов. В хеш-таблице попытка вставки дубликата <u>обновляет</u> значение.



### Что Вы должны сделать:

В данной работе реализация словаря и хеш-таблицы **разбивается** **на** следующие **варианты**:

- **словарь** (далее С) - реализуют те, у кого **2, 4 вариант;**

- **хеш-таблица** (далее Х) - реализуют те, у кого **1, 3 вариант**.

Для заполнения структур вы обязаны использовать подготовленные наборы данных (для С файл - *names.txt*, для Х файл - *cities.txt*). 

Ниже представлен список **индивидуальных** заданий:

- вариант 1: реализация - 
  - слияния хеш-таблиц;
  - вывода городов в обратном алфавитном порядке;
- вариант 2: выдать - 
  - все номера для людей с одинаковой фамилией;
  - самое длинное <u>имя</u>;[1]
- вариант 3: реализовать -  
  - выдачу имен городов, расположенных в одной (указанной) стране;
  - проверку, входит ли указанный город в указанную страну;
- вариант 4: реализация - 
  - слияния словарей;
  - обмена словарей (*swap*).

##### [1]: Вместе с номером, фамилией и отчеством. Например: имеется строка `Feodalov Alexsandr Petro, 81234567890`, чьё имя (`Alexsandr`) является самым длинным в словаре, соответственно функция выведет в консоль полную информацию (ФИО и номер).

** **

Ваши **структуры должны** поддерживать реализации индивидуальных заданий (если не было указано иное).  При этом, **решения индивидуальных заданий не должны являться методами** ваших классов (т.е. **решение задания - внешняя функция** взаимодействующая с вашей структурой). Помимо обязательного интерфейса (общее задание) вы можете реализовать свои дополнительные методы для решения задач. 

### Сборка

Все представленные ниже инструкции используются для _*nix_ семейства ОС.  Для пользователей ОС Windows может понадобиться использование других инструкций (либо вы можете использовать *Cygwin* или *MinGW*).

Для сборки с помощью `make` (Makefile):

```bash
$ cd <to repo path>/lab_04
$ make
```

Для сборки с помощью `cmake` (CMakeLists.txt):

```bash
$ cd <to repo path>/lab_04
$ cmake .
$ make
```

### Отчёт

В отчёте должно содержаться:

- перечисление **выполненных** заданий;
- листинг (код) программы;
- тестирование программы;
- получение производительности основных операций ваших структур;
- вывод скомпилированной программы;
- вывод по проделанной работе.